/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-virtual";
exports.ids = ["vendor-chunks/react-virtual"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-virtual/dist/react-virtual.development.js":
/*!**********************************************************************!*\
  !*** ./node_modules/react-virtual/dist/react-virtual.development.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("(function (global, factory) {\n   true ? factory(exports, __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\")) :\n  0;\n}(this, (function (exports, React) { 'use strict';\n\n  React = React && Object.prototype.hasOwnProperty.call(React, 'default') ? React['default'] : React;\n\n  function _extends() {\n    _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n\n      return target;\n    };\n\n    return _extends.apply(this, arguments);\n  }\n\n  function _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n\n    for (i = 0; i < sourceKeys.length; i++) {\n      key = sourceKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      target[key] = source[key];\n    }\n\n    return target;\n  }\n\n  var props = ['bottom', 'height', 'left', 'right', 'top', 'width'];\n\n  var rectChanged = function rectChanged(a, b) {\n    if (a === void 0) {\n      a = {};\n    }\n\n    if (b === void 0) {\n      b = {};\n    }\n\n    return props.some(function (prop) {\n      return a[prop] !== b[prop];\n    });\n  };\n\n  var observedNodes = /*#__PURE__*/new Map();\n  var rafId;\n\n  var run = function run() {\n    var changedStates = [];\n    observedNodes.forEach(function (state, node) {\n      var newRect = node.getBoundingClientRect();\n\n      if (rectChanged(newRect, state.rect)) {\n        state.rect = newRect;\n        changedStates.push(state);\n      }\n    });\n    changedStates.forEach(function (state) {\n      state.callbacks.forEach(function (cb) {\n        return cb(state.rect);\n      });\n    });\n    rafId = window.requestAnimationFrame(run);\n  };\n\n  function observeRect(node, cb) {\n    return {\n      observe: function observe() {\n        var wasEmpty = observedNodes.size === 0;\n\n        if (observedNodes.has(node)) {\n          observedNodes.get(node).callbacks.push(cb);\n        } else {\n          observedNodes.set(node, {\n            rect: undefined,\n            hasRectChanged: false,\n            callbacks: [cb]\n          });\n        }\n\n        if (wasEmpty) run();\n      },\n      unobserve: function unobserve() {\n        var state = observedNodes.get(node);\n\n        if (state) {\n          // Remove the callback\n          var index = state.callbacks.indexOf(cb);\n          if (index >= 0) state.callbacks.splice(index, 1); // Remove the node reference\n\n          if (!state.callbacks.length) observedNodes[\"delete\"](node); // Stop the loop\n\n          if (!observedNodes.size) cancelAnimationFrame(rafId);\n        }\n      }\n    };\n  }\n\n  var useIsomorphicLayoutEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;\n\n  function useRect(nodeRef, initialRect) {\n    if (initialRect === void 0) {\n      initialRect = {\n        width: 0,\n        height: 0\n      };\n    }\n\n    var _React$useState = React.useState(nodeRef.current),\n        element = _React$useState[0],\n        setElement = _React$useState[1];\n\n    var _React$useReducer = React.useReducer(rectReducer, initialRect),\n        rect = _React$useReducer[0],\n        dispatch = _React$useReducer[1];\n\n    var initialRectSet = React.useRef(false);\n    useIsomorphicLayoutEffect(function () {\n      if (nodeRef.current !== element) {\n        setElement(nodeRef.current);\n      }\n    });\n    useIsomorphicLayoutEffect(function () {\n      if (element && !initialRectSet.current) {\n        initialRectSet.current = true;\n\n        var _rect = element.getBoundingClientRect();\n\n        dispatch({\n          rect: _rect\n        });\n      }\n    }, [element]);\n    React.useEffect(function () {\n      if (!element) {\n        return;\n      }\n\n      var observer = observeRect(element, function (rect) {\n        dispatch({\n          rect: rect\n        });\n      });\n      observer.observe();\n      return function () {\n        observer.unobserve();\n      };\n    }, [element]);\n    return rect;\n  }\n\n  function rectReducer(state, action) {\n    var rect = action.rect;\n\n    if (state.height !== rect.height || state.width !== rect.width) {\n      return rect;\n    }\n\n    return state;\n  }\n\n  var defaultEstimateSize = function defaultEstimateSize() {\n    return 50;\n  };\n\n  var defaultKeyExtractor = function defaultKeyExtractor(index) {\n    return index;\n  };\n\n  var defaultMeasureSize = function defaultMeasureSize(el, horizontal) {\n    var key = horizontal ? 'offsetWidth' : 'offsetHeight';\n    return el[key];\n  };\n\n  var defaultRangeExtractor = function defaultRangeExtractor(range) {\n    var start = Math.max(range.start - range.overscan, 0);\n    var end = Math.min(range.end + range.overscan, range.size - 1);\n    var arr = [];\n\n    for (var i = start; i <= end; i++) {\n      arr.push(i);\n    }\n\n    return arr;\n  };\n  function useVirtual(_ref) {\n    var _measurements;\n\n    var _ref$size = _ref.size,\n        size = _ref$size === void 0 ? 0 : _ref$size,\n        _ref$estimateSize = _ref.estimateSize,\n        estimateSize = _ref$estimateSize === void 0 ? defaultEstimateSize : _ref$estimateSize,\n        _ref$overscan = _ref.overscan,\n        overscan = _ref$overscan === void 0 ? 1 : _ref$overscan,\n        _ref$paddingStart = _ref.paddingStart,\n        paddingStart = _ref$paddingStart === void 0 ? 0 : _ref$paddingStart,\n        _ref$paddingEnd = _ref.paddingEnd,\n        paddingEnd = _ref$paddingEnd === void 0 ? 0 : _ref$paddingEnd,\n        parentRef = _ref.parentRef,\n        horizontal = _ref.horizontal,\n        scrollToFn = _ref.scrollToFn,\n        useObserver = _ref.useObserver,\n        initialRect = _ref.initialRect,\n        onScrollElement = _ref.onScrollElement,\n        scrollOffsetFn = _ref.scrollOffsetFn,\n        _ref$keyExtractor = _ref.keyExtractor,\n        keyExtractor = _ref$keyExtractor === void 0 ? defaultKeyExtractor : _ref$keyExtractor,\n        _ref$measureSize = _ref.measureSize,\n        measureSize = _ref$measureSize === void 0 ? defaultMeasureSize : _ref$measureSize,\n        _ref$rangeExtractor = _ref.rangeExtractor,\n        rangeExtractor = _ref$rangeExtractor === void 0 ? defaultRangeExtractor : _ref$rangeExtractor;\n    var sizeKey = horizontal ? 'width' : 'height';\n    var scrollKey = horizontal ? 'scrollLeft' : 'scrollTop';\n    var latestRef = React.useRef({\n      scrollOffset: 0,\n      measurements: []\n    });\n\n    var _React$useState = React.useState(0),\n        scrollOffset = _React$useState[0],\n        setScrollOffset = _React$useState[1];\n\n    latestRef.current.scrollOffset = scrollOffset;\n    var useMeasureParent = useObserver || useRect;\n\n    var _useMeasureParent = useMeasureParent(parentRef, initialRect),\n        outerSize = _useMeasureParent[sizeKey];\n\n    latestRef.current.outerSize = outerSize;\n    var defaultScrollToFn = React.useCallback(function (offset) {\n      if (parentRef.current) {\n        parentRef.current[scrollKey] = offset;\n      }\n    }, [parentRef, scrollKey]);\n    var resolvedScrollToFn = scrollToFn || defaultScrollToFn;\n    scrollToFn = React.useCallback(function (offset) {\n      resolvedScrollToFn(offset, defaultScrollToFn);\n    }, [defaultScrollToFn, resolvedScrollToFn]);\n\n    var _React$useState2 = React.useState({}),\n        measuredCache = _React$useState2[0],\n        setMeasuredCache = _React$useState2[1];\n\n    var measure = React.useCallback(function () {\n      return setMeasuredCache({});\n    }, []);\n    var pendingMeasuredCacheIndexesRef = React.useRef([]);\n    var measurements = React.useMemo(function () {\n      var min = pendingMeasuredCacheIndexesRef.current.length > 0 ? Math.min.apply(Math, pendingMeasuredCacheIndexesRef.current) : 0;\n      pendingMeasuredCacheIndexesRef.current = [];\n      var measurements = latestRef.current.measurements.slice(0, min);\n\n      for (var i = min; i < size; i++) {\n        var key = keyExtractor(i);\n        var measuredSize = measuredCache[key];\n\n        var _start = measurements[i - 1] ? measurements[i - 1].end : paddingStart;\n\n        var _size = typeof measuredSize === 'number' ? measuredSize : estimateSize(i);\n\n        var _end = _start + _size;\n\n        measurements[i] = {\n          index: i,\n          start: _start,\n          size: _size,\n          end: _end,\n          key: key\n        };\n      }\n\n      return measurements;\n    }, [estimateSize, measuredCache, paddingStart, size, keyExtractor]);\n    var totalSize = (((_measurements = measurements[size - 1]) == null ? void 0 : _measurements.end) || paddingStart) + paddingEnd;\n    latestRef.current.measurements = measurements;\n    latestRef.current.totalSize = totalSize;\n    var element = onScrollElement ? onScrollElement.current : parentRef.current;\n    var scrollOffsetFnRef = React.useRef(scrollOffsetFn);\n    scrollOffsetFnRef.current = scrollOffsetFn;\n    useIsomorphicLayoutEffect(function () {\n      if (!element) {\n        setScrollOffset(0);\n        return;\n      }\n\n      var onScroll = function onScroll(event) {\n        var offset = scrollOffsetFnRef.current ? scrollOffsetFnRef.current(event) : element[scrollKey];\n        setScrollOffset(offset);\n      };\n\n      onScroll();\n      element.addEventListener('scroll', onScroll, {\n        capture: false,\n        passive: true\n      });\n      return function () {\n        element.removeEventListener('scroll', onScroll);\n      };\n    }, [element, scrollKey]);\n\n    var _calculateRange = calculateRange(latestRef.current),\n        start = _calculateRange.start,\n        end = _calculateRange.end;\n\n    var indexes = React.useMemo(function () {\n      return rangeExtractor({\n        start: start,\n        end: end,\n        overscan: overscan,\n        size: measurements.length\n      });\n    }, [start, end, overscan, measurements.length, rangeExtractor]);\n    var measureSizeRef = React.useRef(measureSize);\n    measureSizeRef.current = measureSize;\n    var virtualItems = React.useMemo(function () {\n      var virtualItems = [];\n\n      var _loop = function _loop(k, len) {\n        var i = indexes[k];\n        var measurement = measurements[i];\n\n        var item = _extends(_extends({}, measurement), {}, {\n          measureRef: function measureRef(el) {\n            if (el) {\n              var measuredSize = measureSizeRef.current(el, horizontal);\n\n              if (measuredSize !== item.size) {\n                var _scrollOffset = latestRef.current.scrollOffset;\n\n                if (item.start < _scrollOffset) {\n                  defaultScrollToFn(_scrollOffset + (measuredSize - item.size));\n                }\n\n                pendingMeasuredCacheIndexesRef.current.push(i);\n                setMeasuredCache(function (old) {\n                  var _extends2;\n\n                  return _extends(_extends({}, old), {}, (_extends2 = {}, _extends2[item.key] = measuredSize, _extends2));\n                });\n              }\n            }\n          }\n        });\n\n        virtualItems.push(item);\n      };\n\n      for (var k = 0, len = indexes.length; k < len; k++) {\n        _loop(k);\n      }\n\n      return virtualItems;\n    }, [indexes, defaultScrollToFn, horizontal, measurements]);\n    var mountedRef = React.useRef(false);\n    useIsomorphicLayoutEffect(function () {\n      if (mountedRef.current) {\n        setMeasuredCache({});\n      }\n\n      mountedRef.current = true;\n    }, [estimateSize]);\n    var scrollToOffset = React.useCallback(function (toOffset, _temp) {\n      var _ref2 = _temp === void 0 ? {} : _temp,\n          _ref2$align = _ref2.align,\n          align = _ref2$align === void 0 ? 'start' : _ref2$align;\n\n      var _latestRef$current = latestRef.current,\n          scrollOffset = _latestRef$current.scrollOffset,\n          outerSize = _latestRef$current.outerSize;\n\n      if (align === 'auto') {\n        if (toOffset <= scrollOffset) {\n          align = 'start';\n        } else if (toOffset >= scrollOffset + outerSize) {\n          align = 'end';\n        } else {\n          align = 'start';\n        }\n      }\n\n      if (align === 'start') {\n        scrollToFn(toOffset);\n      } else if (align === 'end') {\n        scrollToFn(toOffset - outerSize);\n      } else if (align === 'center') {\n        scrollToFn(toOffset - outerSize / 2);\n      }\n    }, [scrollToFn]);\n    var tryScrollToIndex = React.useCallback(function (index, _temp2) {\n      var _ref3 = _temp2 === void 0 ? {} : _temp2,\n          _ref3$align = _ref3.align,\n          align = _ref3$align === void 0 ? 'auto' : _ref3$align,\n          rest = _objectWithoutPropertiesLoose(_ref3, [\"align\"]);\n\n      var _latestRef$current2 = latestRef.current,\n          measurements = _latestRef$current2.measurements,\n          scrollOffset = _latestRef$current2.scrollOffset,\n          outerSize = _latestRef$current2.outerSize;\n      var measurement = measurements[Math.max(0, Math.min(index, size - 1))];\n\n      if (!measurement) {\n        return;\n      }\n\n      if (align === 'auto') {\n        if (measurement.end >= scrollOffset + outerSize) {\n          align = 'end';\n        } else if (measurement.start <= scrollOffset) {\n          align = 'start';\n        } else {\n          return;\n        }\n      }\n\n      var toOffset = align === 'center' ? measurement.start + measurement.size / 2 : align === 'end' ? measurement.end : measurement.start;\n      scrollToOffset(toOffset, _extends({\n        align: align\n      }, rest));\n    }, [scrollToOffset, size]);\n    var scrollToIndex = React.useCallback(function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      // We do a double request here because of\n      // dynamic sizes which can cause offset shift\n      // and end up in the wrong spot. Unfortunately,\n      // we can't know about those dynamic sizes until\n      // we try and render them. So double down!\n      tryScrollToIndex.apply(void 0, args);\n      requestAnimationFrame(function () {\n        tryScrollToIndex.apply(void 0, args);\n      });\n    }, [tryScrollToIndex]);\n    return {\n      virtualItems: virtualItems,\n      totalSize: totalSize,\n      scrollToOffset: scrollToOffset,\n      scrollToIndex: scrollToIndex,\n      measure: measure\n    };\n  }\n\n  var findNearestBinarySearch = function findNearestBinarySearch(low, high, getCurrentValue, value) {\n    while (low <= high) {\n      var middle = (low + high) / 2 | 0;\n      var currentValue = getCurrentValue(middle);\n\n      if (currentValue < value) {\n        low = middle + 1;\n      } else if (currentValue > value) {\n        high = middle - 1;\n      } else {\n        return middle;\n      }\n    }\n\n    if (low > 0) {\n      return low - 1;\n    } else {\n      return 0;\n    }\n  };\n\n  function calculateRange(_ref4) {\n    var measurements = _ref4.measurements,\n        outerSize = _ref4.outerSize,\n        scrollOffset = _ref4.scrollOffset;\n    var size = measurements.length - 1;\n\n    var getOffset = function getOffset(index) {\n      return measurements[index].start;\n    };\n\n    var start = findNearestBinarySearch(0, size, getOffset, scrollOffset);\n    var end = start;\n\n    while (end < size && measurements[end].end < scrollOffset + outerSize) {\n      end++;\n    }\n\n    return {\n      start: start,\n      end: end\n    };\n  }\n\n  exports.defaultRangeExtractor = defaultRangeExtractor;\n  exports.useVirtual = useVirtual;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=react-virtual.development.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtdmlydHVhbC9kaXN0L3JlYWN0LXZpcnR1YWwuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxFQUFFLEtBQTRELG9CQUFvQixtQkFBTyxDQUFDLHdHQUFPO0FBQ2pHLEVBQUUsQ0FDd0U7QUFDMUUsQ0FBQyxvQ0FBb0M7O0FBRXJDOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDs7QUFFNUQsc0VBQXNFOztBQUV0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLDRDQUE0QztBQUM1QztBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVDQUF1QyxrQkFBa0I7QUFDekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkMsVUFBVSxpQkFBaUI7QUFDeEUsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QztBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsMEVBQTBFLGFBQWE7QUFDdkY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpREFBaUQsYUFBYTs7QUFFOUQsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGFpbHdpbmQtbmV4dGpzLXN0YXJ0ZXItYmxvZy8uL25vZGVfbW9kdWxlcy9yZWFjdC12aXJ0dWFsL2Rpc3QvcmVhY3QtdmlydHVhbC5kZXZlbG9wbWVudC5qcz9iY2M1Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgncmVhY3QnKSkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ3JlYWN0J10sIGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5SZWFjdFF1ZXJ5ID0ge30sIGdsb2JhbC5SZWFjdCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsIFJlYWN0KSB7ICd1c2Ugc3RyaWN0JztcblxuICBSZWFjdCA9IFJlYWN0ICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChSZWFjdCwgJ2RlZmF1bHQnKSA/IFJlYWN0WydkZWZhdWx0J10gOiBSZWFjdDtcblxuICBmdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcblxuICAgIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICAgIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICAgIHZhciB0YXJnZXQgPSB7fTtcbiAgICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgdmFyIGtleSwgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIHZhciBwcm9wcyA9IFsnYm90dG9tJywgJ2hlaWdodCcsICdsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICd3aWR0aCddO1xuXG4gIHZhciByZWN0Q2hhbmdlZCA9IGZ1bmN0aW9uIHJlY3RDaGFuZ2VkKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gdm9pZCAwKSB7XG4gICAgICBhID0ge307XG4gICAgfVxuXG4gICAgaWYgKGIgPT09IHZvaWQgMCkge1xuICAgICAgYiA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiBwcm9wcy5zb21lKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICByZXR1cm4gYVtwcm9wXSAhPT0gYltwcm9wXTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgb2JzZXJ2ZWROb2RlcyA9IC8qI19fUFVSRV9fKi9uZXcgTWFwKCk7XG4gIHZhciByYWZJZDtcblxuICB2YXIgcnVuID0gZnVuY3Rpb24gcnVuKCkge1xuICAgIHZhciBjaGFuZ2VkU3RhdGVzID0gW107XG4gICAgb2JzZXJ2ZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSkge1xuICAgICAgdmFyIG5ld1JlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICBpZiAocmVjdENoYW5nZWQobmV3UmVjdCwgc3RhdGUucmVjdCkpIHtcbiAgICAgICAgc3RhdGUucmVjdCA9IG5ld1JlY3Q7XG4gICAgICAgIGNoYW5nZWRTdGF0ZXMucHVzaChzdGF0ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY2hhbmdlZFN0YXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgc3RhdGUuY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHJldHVybiBjYihzdGF0ZS5yZWN0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJhZklkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShydW4pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG9ic2VydmVSZWN0KG5vZGUsIGNiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9ic2VydmU6IGZ1bmN0aW9uIG9ic2VydmUoKSB7XG4gICAgICAgIHZhciB3YXNFbXB0eSA9IG9ic2VydmVkTm9kZXMuc2l6ZSA9PT0gMDtcblxuICAgICAgICBpZiAob2JzZXJ2ZWROb2Rlcy5oYXMobm9kZSkpIHtcbiAgICAgICAgICBvYnNlcnZlZE5vZGVzLmdldChub2RlKS5jYWxsYmFja3MucHVzaChjYik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JzZXJ2ZWROb2Rlcy5zZXQobm9kZSwge1xuICAgICAgICAgICAgcmVjdDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaGFzUmVjdENoYW5nZWQ6IGZhbHNlLFxuICAgICAgICAgICAgY2FsbGJhY2tzOiBbY2JdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAod2FzRW1wdHkpIHJ1bigpO1xuICAgICAgfSxcbiAgICAgIHVub2JzZXJ2ZTogZnVuY3Rpb24gdW5vYnNlcnZlKCkge1xuICAgICAgICB2YXIgc3RhdGUgPSBvYnNlcnZlZE5vZGVzLmdldChub2RlKTtcblxuICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgdGhlIGNhbGxiYWNrXG4gICAgICAgICAgdmFyIGluZGV4ID0gc3RhdGUuY2FsbGJhY2tzLmluZGV4T2YoY2IpO1xuICAgICAgICAgIGlmIChpbmRleCA+PSAwKSBzdGF0ZS5jYWxsYmFja3Muc3BsaWNlKGluZGV4LCAxKTsgLy8gUmVtb3ZlIHRoZSBub2RlIHJlZmVyZW5jZVxuXG4gICAgICAgICAgaWYgKCFzdGF0ZS5jYWxsYmFja3MubGVuZ3RoKSBvYnNlcnZlZE5vZGVzW1wiZGVsZXRlXCJdKG5vZGUpOyAvLyBTdG9wIHRoZSBsb29wXG5cbiAgICAgICAgICBpZiAoIW9ic2VydmVkTm9kZXMuc2l6ZSkgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmSWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHZhciB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiBSZWFjdC51c2VFZmZlY3Q7XG5cbiAgZnVuY3Rpb24gdXNlUmVjdChub2RlUmVmLCBpbml0aWFsUmVjdCkge1xuICAgIGlmIChpbml0aWFsUmVjdCA9PT0gdm9pZCAwKSB7XG4gICAgICBpbml0aWFsUmVjdCA9IHtcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMFxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUobm9kZVJlZi5jdXJyZW50KSxcbiAgICAgICAgZWxlbWVudCA9IF9SZWFjdCR1c2VTdGF0ZVswXSxcbiAgICAgICAgc2V0RWxlbWVudCA9IF9SZWFjdCR1c2VTdGF0ZVsxXTtcblxuICAgIHZhciBfUmVhY3QkdXNlUmVkdWNlciA9IFJlYWN0LnVzZVJlZHVjZXIocmVjdFJlZHVjZXIsIGluaXRpYWxSZWN0KSxcbiAgICAgICAgcmVjdCA9IF9SZWFjdCR1c2VSZWR1Y2VyWzBdLFxuICAgICAgICBkaXNwYXRjaCA9IF9SZWFjdCR1c2VSZWR1Y2VyWzFdO1xuXG4gICAgdmFyIGluaXRpYWxSZWN0U2V0ID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChub2RlUmVmLmN1cnJlbnQgIT09IGVsZW1lbnQpIHtcbiAgICAgICAgc2V0RWxlbWVudChub2RlUmVmLmN1cnJlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGVsZW1lbnQgJiYgIWluaXRpYWxSZWN0U2V0LmN1cnJlbnQpIHtcbiAgICAgICAgaW5pdGlhbFJlY3RTZXQuY3VycmVudCA9IHRydWU7XG5cbiAgICAgICAgdmFyIF9yZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgcmVjdDogX3JlY3RcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgW2VsZW1lbnRdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG9ic2VydmVyID0gb2JzZXJ2ZVJlY3QoZWxlbWVudCwgZnVuY3Rpb24gKHJlY3QpIHtcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIHJlY3Q6IHJlY3RcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIG9ic2VydmVyLm9ic2VydmUoKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9ic2VydmVyLnVub2JzZXJ2ZSgpO1xuICAgICAgfTtcbiAgICB9LCBbZWxlbWVudF0pO1xuICAgIHJldHVybiByZWN0O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjdFJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAgIHZhciByZWN0ID0gYWN0aW9uLnJlY3Q7XG5cbiAgICBpZiAoc3RhdGUuaGVpZ2h0ICE9PSByZWN0LmhlaWdodCB8fCBzdGF0ZS53aWR0aCAhPT0gcmVjdC53aWR0aCkge1xuICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgdmFyIGRlZmF1bHRFc3RpbWF0ZVNpemUgPSBmdW5jdGlvbiBkZWZhdWx0RXN0aW1hdGVTaXplKCkge1xuICAgIHJldHVybiA1MDtcbiAgfTtcblxuICB2YXIgZGVmYXVsdEtleUV4dHJhY3RvciA9IGZ1bmN0aW9uIGRlZmF1bHRLZXlFeHRyYWN0b3IoaW5kZXgpIHtcbiAgICByZXR1cm4gaW5kZXg7XG4gIH07XG5cbiAgdmFyIGRlZmF1bHRNZWFzdXJlU2l6ZSA9IGZ1bmN0aW9uIGRlZmF1bHRNZWFzdXJlU2l6ZShlbCwgaG9yaXpvbnRhbCkge1xuICAgIHZhciBrZXkgPSBob3Jpem9udGFsID8gJ29mZnNldFdpZHRoJyA6ICdvZmZzZXRIZWlnaHQnO1xuICAgIHJldHVybiBlbFtrZXldO1xuICB9O1xuXG4gIHZhciBkZWZhdWx0UmFuZ2VFeHRyYWN0b3IgPSBmdW5jdGlvbiBkZWZhdWx0UmFuZ2VFeHRyYWN0b3IocmFuZ2UpIHtcbiAgICB2YXIgc3RhcnQgPSBNYXRoLm1heChyYW5nZS5zdGFydCAtIHJhbmdlLm92ZXJzY2FuLCAwKTtcbiAgICB2YXIgZW5kID0gTWF0aC5taW4ocmFuZ2UuZW5kICsgcmFuZ2Uub3ZlcnNjYW4sIHJhbmdlLnNpemUgLSAxKTtcbiAgICB2YXIgYXJyID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICAgIGFyci5wdXNoKGkpO1xuICAgIH1cblxuICAgIHJldHVybiBhcnI7XG4gIH07XG4gIGZ1bmN0aW9uIHVzZVZpcnR1YWwoX3JlZikge1xuICAgIHZhciBfbWVhc3VyZW1lbnRzO1xuXG4gICAgdmFyIF9yZWYkc2l6ZSA9IF9yZWYuc2l6ZSxcbiAgICAgICAgc2l6ZSA9IF9yZWYkc2l6ZSA9PT0gdm9pZCAwID8gMCA6IF9yZWYkc2l6ZSxcbiAgICAgICAgX3JlZiRlc3RpbWF0ZVNpemUgPSBfcmVmLmVzdGltYXRlU2l6ZSxcbiAgICAgICAgZXN0aW1hdGVTaXplID0gX3JlZiRlc3RpbWF0ZVNpemUgPT09IHZvaWQgMCA/IGRlZmF1bHRFc3RpbWF0ZVNpemUgOiBfcmVmJGVzdGltYXRlU2l6ZSxcbiAgICAgICAgX3JlZiRvdmVyc2NhbiA9IF9yZWYub3ZlcnNjYW4sXG4gICAgICAgIG92ZXJzY2FuID0gX3JlZiRvdmVyc2NhbiA9PT0gdm9pZCAwID8gMSA6IF9yZWYkb3ZlcnNjYW4sXG4gICAgICAgIF9yZWYkcGFkZGluZ1N0YXJ0ID0gX3JlZi5wYWRkaW5nU3RhcnQsXG4gICAgICAgIHBhZGRpbmdTdGFydCA9IF9yZWYkcGFkZGluZ1N0YXJ0ID09PSB2b2lkIDAgPyAwIDogX3JlZiRwYWRkaW5nU3RhcnQsXG4gICAgICAgIF9yZWYkcGFkZGluZ0VuZCA9IF9yZWYucGFkZGluZ0VuZCxcbiAgICAgICAgcGFkZGluZ0VuZCA9IF9yZWYkcGFkZGluZ0VuZCA9PT0gdm9pZCAwID8gMCA6IF9yZWYkcGFkZGluZ0VuZCxcbiAgICAgICAgcGFyZW50UmVmID0gX3JlZi5wYXJlbnRSZWYsXG4gICAgICAgIGhvcml6b250YWwgPSBfcmVmLmhvcml6b250YWwsXG4gICAgICAgIHNjcm9sbFRvRm4gPSBfcmVmLnNjcm9sbFRvRm4sXG4gICAgICAgIHVzZU9ic2VydmVyID0gX3JlZi51c2VPYnNlcnZlcixcbiAgICAgICAgaW5pdGlhbFJlY3QgPSBfcmVmLmluaXRpYWxSZWN0LFxuICAgICAgICBvblNjcm9sbEVsZW1lbnQgPSBfcmVmLm9uU2Nyb2xsRWxlbWVudCxcbiAgICAgICAgc2Nyb2xsT2Zmc2V0Rm4gPSBfcmVmLnNjcm9sbE9mZnNldEZuLFxuICAgICAgICBfcmVmJGtleUV4dHJhY3RvciA9IF9yZWYua2V5RXh0cmFjdG9yLFxuICAgICAgICBrZXlFeHRyYWN0b3IgPSBfcmVmJGtleUV4dHJhY3RvciA9PT0gdm9pZCAwID8gZGVmYXVsdEtleUV4dHJhY3RvciA6IF9yZWYka2V5RXh0cmFjdG9yLFxuICAgICAgICBfcmVmJG1lYXN1cmVTaXplID0gX3JlZi5tZWFzdXJlU2l6ZSxcbiAgICAgICAgbWVhc3VyZVNpemUgPSBfcmVmJG1lYXN1cmVTaXplID09PSB2b2lkIDAgPyBkZWZhdWx0TWVhc3VyZVNpemUgOiBfcmVmJG1lYXN1cmVTaXplLFxuICAgICAgICBfcmVmJHJhbmdlRXh0cmFjdG9yID0gX3JlZi5yYW5nZUV4dHJhY3RvcixcbiAgICAgICAgcmFuZ2VFeHRyYWN0b3IgPSBfcmVmJHJhbmdlRXh0cmFjdG9yID09PSB2b2lkIDAgPyBkZWZhdWx0UmFuZ2VFeHRyYWN0b3IgOiBfcmVmJHJhbmdlRXh0cmFjdG9yO1xuICAgIHZhciBzaXplS2V5ID0gaG9yaXpvbnRhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICB2YXIgc2Nyb2xsS2V5ID0gaG9yaXpvbnRhbCA/ICdzY3JvbGxMZWZ0JyA6ICdzY3JvbGxUb3AnO1xuICAgIHZhciBsYXRlc3RSZWYgPSBSZWFjdC51c2VSZWYoe1xuICAgICAgc2Nyb2xsT2Zmc2V0OiAwLFxuICAgICAgbWVhc3VyZW1lbnRzOiBbXVxuICAgIH0pO1xuXG4gICAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKDApLFxuICAgICAgICBzY3JvbGxPZmZzZXQgPSBfUmVhY3QkdXNlU3RhdGVbMF0sXG4gICAgICAgIHNldFNjcm9sbE9mZnNldCA9IF9SZWFjdCR1c2VTdGF0ZVsxXTtcblxuICAgIGxhdGVzdFJlZi5jdXJyZW50LnNjcm9sbE9mZnNldCA9IHNjcm9sbE9mZnNldDtcbiAgICB2YXIgdXNlTWVhc3VyZVBhcmVudCA9IHVzZU9ic2VydmVyIHx8IHVzZVJlY3Q7XG5cbiAgICB2YXIgX3VzZU1lYXN1cmVQYXJlbnQgPSB1c2VNZWFzdXJlUGFyZW50KHBhcmVudFJlZiwgaW5pdGlhbFJlY3QpLFxuICAgICAgICBvdXRlclNpemUgPSBfdXNlTWVhc3VyZVBhcmVudFtzaXplS2V5XTtcblxuICAgIGxhdGVzdFJlZi5jdXJyZW50Lm91dGVyU2l6ZSA9IG91dGVyU2l6ZTtcbiAgICB2YXIgZGVmYXVsdFNjcm9sbFRvRm4gPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICBpZiAocGFyZW50UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcGFyZW50UmVmLmN1cnJlbnRbc2Nyb2xsS2V5XSA9IG9mZnNldDtcbiAgICAgIH1cbiAgICB9LCBbcGFyZW50UmVmLCBzY3JvbGxLZXldKTtcbiAgICB2YXIgcmVzb2x2ZWRTY3JvbGxUb0ZuID0gc2Nyb2xsVG9GbiB8fCBkZWZhdWx0U2Nyb2xsVG9GbjtcbiAgICBzY3JvbGxUb0ZuID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgcmVzb2x2ZWRTY3JvbGxUb0ZuKG9mZnNldCwgZGVmYXVsdFNjcm9sbFRvRm4pO1xuICAgIH0sIFtkZWZhdWx0U2Nyb2xsVG9GbiwgcmVzb2x2ZWRTY3JvbGxUb0ZuXSk7XG5cbiAgICB2YXIgX1JlYWN0JHVzZVN0YXRlMiA9IFJlYWN0LnVzZVN0YXRlKHt9KSxcbiAgICAgICAgbWVhc3VyZWRDYWNoZSA9IF9SZWFjdCR1c2VTdGF0ZTJbMF0sXG4gICAgICAgIHNldE1lYXN1cmVkQ2FjaGUgPSBfUmVhY3QkdXNlU3RhdGUyWzFdO1xuXG4gICAgdmFyIG1lYXN1cmUgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gc2V0TWVhc3VyZWRDYWNoZSh7fSk7XG4gICAgfSwgW10pO1xuICAgIHZhciBwZW5kaW5nTWVhc3VyZWRDYWNoZUluZGV4ZXNSZWYgPSBSZWFjdC51c2VSZWYoW10pO1xuICAgIHZhciBtZWFzdXJlbWVudHMgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtaW4gPSBwZW5kaW5nTWVhc3VyZWRDYWNoZUluZGV4ZXNSZWYuY3VycmVudC5sZW5ndGggPiAwID8gTWF0aC5taW4uYXBwbHkoTWF0aCwgcGVuZGluZ01lYXN1cmVkQ2FjaGVJbmRleGVzUmVmLmN1cnJlbnQpIDogMDtcbiAgICAgIHBlbmRpbmdNZWFzdXJlZENhY2hlSW5kZXhlc1JlZi5jdXJyZW50ID0gW107XG4gICAgICB2YXIgbWVhc3VyZW1lbnRzID0gbGF0ZXN0UmVmLmN1cnJlbnQubWVhc3VyZW1lbnRzLnNsaWNlKDAsIG1pbik7XG5cbiAgICAgIGZvciAodmFyIGkgPSBtaW47IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleUV4dHJhY3RvcihpKTtcbiAgICAgICAgdmFyIG1lYXN1cmVkU2l6ZSA9IG1lYXN1cmVkQ2FjaGVba2V5XTtcblxuICAgICAgICB2YXIgX3N0YXJ0ID0gbWVhc3VyZW1lbnRzW2kgLSAxXSA/IG1lYXN1cmVtZW50c1tpIC0gMV0uZW5kIDogcGFkZGluZ1N0YXJ0O1xuXG4gICAgICAgIHZhciBfc2l6ZSA9IHR5cGVvZiBtZWFzdXJlZFNpemUgPT09ICdudW1iZXInID8gbWVhc3VyZWRTaXplIDogZXN0aW1hdGVTaXplKGkpO1xuXG4gICAgICAgIHZhciBfZW5kID0gX3N0YXJ0ICsgX3NpemU7XG5cbiAgICAgICAgbWVhc3VyZW1lbnRzW2ldID0ge1xuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIHN0YXJ0OiBfc3RhcnQsXG4gICAgICAgICAgc2l6ZTogX3NpemUsXG4gICAgICAgICAgZW5kOiBfZW5kLFxuICAgICAgICAgIGtleToga2V5XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtZWFzdXJlbWVudHM7XG4gICAgfSwgW2VzdGltYXRlU2l6ZSwgbWVhc3VyZWRDYWNoZSwgcGFkZGluZ1N0YXJ0LCBzaXplLCBrZXlFeHRyYWN0b3JdKTtcbiAgICB2YXIgdG90YWxTaXplID0gKCgoX21lYXN1cmVtZW50cyA9IG1lYXN1cmVtZW50c1tzaXplIC0gMV0pID09IG51bGwgPyB2b2lkIDAgOiBfbWVhc3VyZW1lbnRzLmVuZCkgfHwgcGFkZGluZ1N0YXJ0KSArIHBhZGRpbmdFbmQ7XG4gICAgbGF0ZXN0UmVmLmN1cnJlbnQubWVhc3VyZW1lbnRzID0gbWVhc3VyZW1lbnRzO1xuICAgIGxhdGVzdFJlZi5jdXJyZW50LnRvdGFsU2l6ZSA9IHRvdGFsU2l6ZTtcbiAgICB2YXIgZWxlbWVudCA9IG9uU2Nyb2xsRWxlbWVudCA/IG9uU2Nyb2xsRWxlbWVudC5jdXJyZW50IDogcGFyZW50UmVmLmN1cnJlbnQ7XG4gICAgdmFyIHNjcm9sbE9mZnNldEZuUmVmID0gUmVhY3QudXNlUmVmKHNjcm9sbE9mZnNldEZuKTtcbiAgICBzY3JvbGxPZmZzZXRGblJlZi5jdXJyZW50ID0gc2Nyb2xsT2Zmc2V0Rm47XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgc2V0U2Nyb2xsT2Zmc2V0KDApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBvblNjcm9sbCA9IGZ1bmN0aW9uIG9uU2Nyb2xsKGV2ZW50KSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBzY3JvbGxPZmZzZXRGblJlZi5jdXJyZW50ID8gc2Nyb2xsT2Zmc2V0Rm5SZWYuY3VycmVudChldmVudCkgOiBlbGVtZW50W3Njcm9sbEtleV07XG4gICAgICAgIHNldFNjcm9sbE9mZnNldChvZmZzZXQpO1xuICAgICAgfTtcblxuICAgICAgb25TY3JvbGwoKTtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25TY3JvbGwsIHtcbiAgICAgICAgY2FwdHVyZTogZmFsc2UsXG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvblNjcm9sbCk7XG4gICAgICB9O1xuICAgIH0sIFtlbGVtZW50LCBzY3JvbGxLZXldKTtcblxuICAgIHZhciBfY2FsY3VsYXRlUmFuZ2UgPSBjYWxjdWxhdGVSYW5nZShsYXRlc3RSZWYuY3VycmVudCksXG4gICAgICAgIHN0YXJ0ID0gX2NhbGN1bGF0ZVJhbmdlLnN0YXJ0LFxuICAgICAgICBlbmQgPSBfY2FsY3VsYXRlUmFuZ2UuZW5kO1xuXG4gICAgdmFyIGluZGV4ZXMgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByYW5nZUV4dHJhY3Rvcih7XG4gICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgIG92ZXJzY2FuOiBvdmVyc2NhbixcbiAgICAgICAgc2l6ZTogbWVhc3VyZW1lbnRzLmxlbmd0aFxuICAgICAgfSk7XG4gICAgfSwgW3N0YXJ0LCBlbmQsIG92ZXJzY2FuLCBtZWFzdXJlbWVudHMubGVuZ3RoLCByYW5nZUV4dHJhY3Rvcl0pO1xuICAgIHZhciBtZWFzdXJlU2l6ZVJlZiA9IFJlYWN0LnVzZVJlZihtZWFzdXJlU2l6ZSk7XG4gICAgbWVhc3VyZVNpemVSZWYuY3VycmVudCA9IG1lYXN1cmVTaXplO1xuICAgIHZhciB2aXJ0dWFsSXRlbXMgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2aXJ0dWFsSXRlbXMgPSBbXTtcblxuICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaywgbGVuKSB7XG4gICAgICAgIHZhciBpID0gaW5kZXhlc1trXTtcbiAgICAgICAgdmFyIG1lYXN1cmVtZW50ID0gbWVhc3VyZW1lbnRzW2ldO1xuXG4gICAgICAgIHZhciBpdGVtID0gX2V4dGVuZHMoX2V4dGVuZHMoe30sIG1lYXN1cmVtZW50KSwge30sIHtcbiAgICAgICAgICBtZWFzdXJlUmVmOiBmdW5jdGlvbiBtZWFzdXJlUmVmKGVsKSB7XG4gICAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgICAgdmFyIG1lYXN1cmVkU2l6ZSA9IG1lYXN1cmVTaXplUmVmLmN1cnJlbnQoZWwsIGhvcml6b250YWwpO1xuXG4gICAgICAgICAgICAgIGlmIChtZWFzdXJlZFNpemUgIT09IGl0ZW0uc2l6ZSkge1xuICAgICAgICAgICAgICAgIHZhciBfc2Nyb2xsT2Zmc2V0ID0gbGF0ZXN0UmVmLmN1cnJlbnQuc2Nyb2xsT2Zmc2V0O1xuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uc3RhcnQgPCBfc2Nyb2xsT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0U2Nyb2xsVG9Gbihfc2Nyb2xsT2Zmc2V0ICsgKG1lYXN1cmVkU2l6ZSAtIGl0ZW0uc2l6ZSkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBlbmRpbmdNZWFzdXJlZENhY2hlSW5kZXhlc1JlZi5jdXJyZW50LnB1c2goaSk7XG4gICAgICAgICAgICAgICAgc2V0TWVhc3VyZWRDYWNoZShmdW5jdGlvbiAob2xkKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX2V4dGVuZHMyO1xuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2V4dGVuZHMoX2V4dGVuZHMoe30sIG9sZCksIHt9LCAoX2V4dGVuZHMyID0ge30sIF9leHRlbmRzMltpdGVtLmtleV0gPSBtZWFzdXJlZFNpemUsIF9leHRlbmRzMikpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2aXJ0dWFsSXRlbXMucHVzaChpdGVtKTtcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGsgPSAwLCBsZW4gPSBpbmRleGVzLmxlbmd0aDsgayA8IGxlbjsgaysrKSB7XG4gICAgICAgIF9sb29wKGspO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmlydHVhbEl0ZW1zO1xuICAgIH0sIFtpbmRleGVzLCBkZWZhdWx0U2Nyb2xsVG9GbiwgaG9yaXpvbnRhbCwgbWVhc3VyZW1lbnRzXSk7XG4gICAgdmFyIG1vdW50ZWRSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG1vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgICBzZXRNZWFzdXJlZENhY2hlKHt9KTtcbiAgICAgIH1cblxuICAgICAgbW91bnRlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9LCBbZXN0aW1hdGVTaXplXSk7XG4gICAgdmFyIHNjcm9sbFRvT2Zmc2V0ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHRvT2Zmc2V0LCBfdGVtcCkge1xuICAgICAgdmFyIF9yZWYyID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAsXG4gICAgICAgICAgX3JlZjIkYWxpZ24gPSBfcmVmMi5hbGlnbixcbiAgICAgICAgICBhbGlnbiA9IF9yZWYyJGFsaWduID09PSB2b2lkIDAgPyAnc3RhcnQnIDogX3JlZjIkYWxpZ247XG5cbiAgICAgIHZhciBfbGF0ZXN0UmVmJGN1cnJlbnQgPSBsYXRlc3RSZWYuY3VycmVudCxcbiAgICAgICAgICBzY3JvbGxPZmZzZXQgPSBfbGF0ZXN0UmVmJGN1cnJlbnQuc2Nyb2xsT2Zmc2V0LFxuICAgICAgICAgIG91dGVyU2l6ZSA9IF9sYXRlc3RSZWYkY3VycmVudC5vdXRlclNpemU7XG5cbiAgICAgIGlmIChhbGlnbiA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIGlmICh0b09mZnNldCA8PSBzY3JvbGxPZmZzZXQpIHtcbiAgICAgICAgICBhbGlnbiA9ICdzdGFydCc7XG4gICAgICAgIH0gZWxzZSBpZiAodG9PZmZzZXQgPj0gc2Nyb2xsT2Zmc2V0ICsgb3V0ZXJTaXplKSB7XG4gICAgICAgICAgYWxpZ24gPSAnZW5kJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbGlnbiA9ICdzdGFydCc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgIHNjcm9sbFRvRm4odG9PZmZzZXQpO1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgc2Nyb2xsVG9Gbih0b09mZnNldCAtIG91dGVyU2l6ZSk7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICBzY3JvbGxUb0ZuKHRvT2Zmc2V0IC0gb3V0ZXJTaXplIC8gMik7XG4gICAgICB9XG4gICAgfSwgW3Njcm9sbFRvRm5dKTtcbiAgICB2YXIgdHJ5U2Nyb2xsVG9JbmRleCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChpbmRleCwgX3RlbXAyKSB7XG4gICAgICB2YXIgX3JlZjMgPSBfdGVtcDIgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAyLFxuICAgICAgICAgIF9yZWYzJGFsaWduID0gX3JlZjMuYWxpZ24sXG4gICAgICAgICAgYWxpZ24gPSBfcmVmMyRhbGlnbiA9PT0gdm9pZCAwID8gJ2F1dG8nIDogX3JlZjMkYWxpZ24sXG4gICAgICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYzLCBbXCJhbGlnblwiXSk7XG5cbiAgICAgIHZhciBfbGF0ZXN0UmVmJGN1cnJlbnQyID0gbGF0ZXN0UmVmLmN1cnJlbnQsXG4gICAgICAgICAgbWVhc3VyZW1lbnRzID0gX2xhdGVzdFJlZiRjdXJyZW50Mi5tZWFzdXJlbWVudHMsXG4gICAgICAgICAgc2Nyb2xsT2Zmc2V0ID0gX2xhdGVzdFJlZiRjdXJyZW50Mi5zY3JvbGxPZmZzZXQsXG4gICAgICAgICAgb3V0ZXJTaXplID0gX2xhdGVzdFJlZiRjdXJyZW50Mi5vdXRlclNpemU7XG4gICAgICB2YXIgbWVhc3VyZW1lbnQgPSBtZWFzdXJlbWVudHNbTWF0aC5tYXgoMCwgTWF0aC5taW4oaW5kZXgsIHNpemUgLSAxKSldO1xuXG4gICAgICBpZiAoIW1lYXN1cmVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGFsaWduID09PSAnYXV0bycpIHtcbiAgICAgICAgaWYgKG1lYXN1cmVtZW50LmVuZCA+PSBzY3JvbGxPZmZzZXQgKyBvdXRlclNpemUpIHtcbiAgICAgICAgICBhbGlnbiA9ICdlbmQnO1xuICAgICAgICB9IGVsc2UgaWYgKG1lYXN1cmVtZW50LnN0YXJ0IDw9IHNjcm9sbE9mZnNldCkge1xuICAgICAgICAgIGFsaWduID0gJ3N0YXJ0JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHRvT2Zmc2V0ID0gYWxpZ24gPT09ICdjZW50ZXInID8gbWVhc3VyZW1lbnQuc3RhcnQgKyBtZWFzdXJlbWVudC5zaXplIC8gMiA6IGFsaWduID09PSAnZW5kJyA/IG1lYXN1cmVtZW50LmVuZCA6IG1lYXN1cmVtZW50LnN0YXJ0O1xuICAgICAgc2Nyb2xsVG9PZmZzZXQodG9PZmZzZXQsIF9leHRlbmRzKHtcbiAgICAgICAgYWxpZ246IGFsaWduXG4gICAgICB9LCByZXN0KSk7XG4gICAgfSwgW3Njcm9sbFRvT2Zmc2V0LCBzaXplXSk7XG4gICAgdmFyIHNjcm9sbFRvSW5kZXggPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgLy8gV2UgZG8gYSBkb3VibGUgcmVxdWVzdCBoZXJlIGJlY2F1c2Ugb2ZcbiAgICAgIC8vIGR5bmFtaWMgc2l6ZXMgd2hpY2ggY2FuIGNhdXNlIG9mZnNldCBzaGlmdFxuICAgICAgLy8gYW5kIGVuZCB1cCBpbiB0aGUgd3Jvbmcgc3BvdC4gVW5mb3J0dW5hdGVseSxcbiAgICAgIC8vIHdlIGNhbid0IGtub3cgYWJvdXQgdGhvc2UgZHluYW1pYyBzaXplcyB1bnRpbFxuICAgICAgLy8gd2UgdHJ5IGFuZCByZW5kZXIgdGhlbS4gU28gZG91YmxlIGRvd24hXG4gICAgICB0cnlTY3JvbGxUb0luZGV4LmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnlTY3JvbGxUb0luZGV4LmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgICB9KTtcbiAgICB9LCBbdHJ5U2Nyb2xsVG9JbmRleF0pO1xuICAgIHJldHVybiB7XG4gICAgICB2aXJ0dWFsSXRlbXM6IHZpcnR1YWxJdGVtcyxcbiAgICAgIHRvdGFsU2l6ZTogdG90YWxTaXplLFxuICAgICAgc2Nyb2xsVG9PZmZzZXQ6IHNjcm9sbFRvT2Zmc2V0LFxuICAgICAgc2Nyb2xsVG9JbmRleDogc2Nyb2xsVG9JbmRleCxcbiAgICAgIG1lYXN1cmU6IG1lYXN1cmVcbiAgICB9O1xuICB9XG5cbiAgdmFyIGZpbmROZWFyZXN0QmluYXJ5U2VhcmNoID0gZnVuY3Rpb24gZmluZE5lYXJlc3RCaW5hcnlTZWFyY2gobG93LCBoaWdoLCBnZXRDdXJyZW50VmFsdWUsIHZhbHVlKSB7XG4gICAgd2hpbGUgKGxvdyA8PSBoaWdoKSB7XG4gICAgICB2YXIgbWlkZGxlID0gKGxvdyArIGhpZ2gpIC8gMiB8IDA7XG4gICAgICB2YXIgY3VycmVudFZhbHVlID0gZ2V0Q3VycmVudFZhbHVlKG1pZGRsZSk7XG5cbiAgICAgIGlmIChjdXJyZW50VmFsdWUgPCB2YWx1ZSkge1xuICAgICAgICBsb3cgPSBtaWRkbGUgKyAxO1xuICAgICAgfSBlbHNlIGlmIChjdXJyZW50VmFsdWUgPiB2YWx1ZSkge1xuICAgICAgICBoaWdoID0gbWlkZGxlIC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtaWRkbGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxvdyA+IDApIHtcbiAgICAgIHJldHVybiBsb3cgLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gY2FsY3VsYXRlUmFuZ2UoX3JlZjQpIHtcbiAgICB2YXIgbWVhc3VyZW1lbnRzID0gX3JlZjQubWVhc3VyZW1lbnRzLFxuICAgICAgICBvdXRlclNpemUgPSBfcmVmNC5vdXRlclNpemUsXG4gICAgICAgIHNjcm9sbE9mZnNldCA9IF9yZWY0LnNjcm9sbE9mZnNldDtcbiAgICB2YXIgc2l6ZSA9IG1lYXN1cmVtZW50cy5sZW5ndGggLSAxO1xuXG4gICAgdmFyIGdldE9mZnNldCA9IGZ1bmN0aW9uIGdldE9mZnNldChpbmRleCkge1xuICAgICAgcmV0dXJuIG1lYXN1cmVtZW50c1tpbmRleF0uc3RhcnQ7XG4gICAgfTtcblxuICAgIHZhciBzdGFydCA9IGZpbmROZWFyZXN0QmluYXJ5U2VhcmNoKDAsIHNpemUsIGdldE9mZnNldCwgc2Nyb2xsT2Zmc2V0KTtcbiAgICB2YXIgZW5kID0gc3RhcnQ7XG5cbiAgICB3aGlsZSAoZW5kIDwgc2l6ZSAmJiBtZWFzdXJlbWVudHNbZW5kXS5lbmQgPCBzY3JvbGxPZmZzZXQgKyBvdXRlclNpemUpIHtcbiAgICAgIGVuZCsrO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogc3RhcnQsXG4gICAgICBlbmQ6IGVuZFxuICAgIH07XG4gIH1cblxuICBleHBvcnRzLmRlZmF1bHRSYW5nZUV4dHJhY3RvciA9IGRlZmF1bHRSYW5nZUV4dHJhY3RvcjtcbiAgZXhwb3J0cy51c2VWaXJ0dWFsID0gdXNlVmlydHVhbDtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhY3QtdmlydHVhbC5kZXZlbG9wbWVudC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-virtual/dist/react-virtual.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-virtual/index.js":
/*!*********************************************!*\
  !*** ./node_modules/react-virtual/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("if (false) {} else {\n  module.exports = __webpack_require__(/*! ./dist/react-virtual.development.js */ \"(ssr)/./node_modules/react-virtual/dist/react-virtual.development.js\")\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtdmlydHVhbC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsdUpBQStEO0FBQ2pFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGFpbHdpbmQtbmV4dGpzLXN0YXJ0ZXItYmxvZy8uL25vZGVfbW9kdWxlcy9yZWFjdC12aXJ0dWFsL2luZGV4LmpzP2E1ZTEiXSwic291cmNlc0NvbnRlbnQiOlsiaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvcmVhY3QtdmlydHVhbC5wcm9kdWN0aW9uLm1pbi5qcycpXG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9yZWFjdC12aXJ0dWFsLmRldmVsb3BtZW50LmpzJylcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-virtual/index.js\n");

/***/ })

};
;